function [solved, w_lower, w_upper] = find_metric_Allgower_SPOT(x1_lim, x2_lim,condn, lambda, ccm_eps,return_metric)

%% State-space and dynamics

x = msspoly('x',2);

f = [-1*x(1) + 2*x(2);
    -3*x(1) + 4*x(2) - 0.25*(x(2)^3)];
B = [0.5;-2];

df = [-1, 2;
     -3, 4-0.75*x(2)^2];

dtwo = msspoly('dtwo',2);

%% Initialize problem

prog = spotsosprog;
prog = prog.withIndeterminate(x);
prog = prog.withIndeterminate(dtwo);

[prog, w_lower] = prog.newPos(1);
[prog, w_upper] = prog.newPos(1);

%% Parameterize W

w_order = 4;
w_poly = monomials(x,0:w_order);
W_list = cell(length(w_poly),1);

[prog, W_list{1}] = prog.newSym(n);
W = W_list{1}*w_poly(1);

for i = 2:length(w_poly)
    [prog, W_list{i}] = prog.newSym(n);
    W = W + W_list{i}*w_poly(i);
end

[prog, W_upper] = prog.newPSD(n);

dW_f = diff(W(:),x)*f;
dW_f = reshape(dW_f,2,2);

%% Killing field conditions

dW_b = diff(W(:),x)*B; %db_dx = 0
prog = prog.withPolyEqs(dW_b);

%%

%Box constraints
box_lim = [x(1)+x1_lim;
           x1_lim-x(1);
           x(2)+x2_lim;
           x2_lim-x(2)];

%Upper and Lower definiteness
l_order = 4;
l_def_states = [x; dfor]';

[prog, Ll] = prog.newSOSPoly(monomials(l_def_states,0:l_order),2);
[prog, Lu] = prog.newSOSPoly(monomials(l_def_states,0:l_order),2);

%CCM condition
[s_ccm_1,c_ccm_1] = polynomial([x;dtwo],4,0);
[s_ccm_2,c_ccm_2] = polynomial([x;dtwo],4,0);
[s_ccm_3,c_ccm_3] = polynomial([x;dtwo],4,0);
[s_ccm_4,c_ccm_4] = polynomial([x;dtwo],4,0);

%CCM condition
R_CCM = -(-dW_f + df*W + W*df' - rho*(B*B') + 2*lambda*W);
p_CCM = dtwo'*R_CCM*dtwo - [s_ccm_1,s_ccm_2,s_ccm_3,s_ccm_4]*box_lim;

%Killing field condition
dW_B = jacobian(W(:),x)*B;
dW_B = reshape(dW_B,2,2);
killing_11 = dW_B(1,1);
killing_11_2 = (-dW_B(1,1));

killing_12 = dW_B(1,2);
killing_12_2 = (-dW_B(1,2));

killing_22 = dW_B(2,2);
killing_22_2 = (-dW_B(2,2));

%W uniform bounds
W_bounds = [w_lower>=0.0035; w_upper>=w_lower];

%Condition bound
W_cond = [w_upper-condn*w_lower <= 0];

%W pos def
p_W_up = (w_upper*(dtwo'*dtwo)-dtwo'*W*dtwo) - ...
    [su_1,su_2,su_3,su_4]*box_lim;

p_W_low = (dtwo'*W*dtwo - w_lower*(dtwo'*dtwo))-...
    [sl_1,sl_2,sl_3,sl_4]*box_lim;

coeff_List = [c_rho;c_11;c_12;c_22;
    c_us_1;c_us_2;c_us_3;c_us_4;c_ls_1;c_ls_2;c_ls_3;c_ls_4;
    c_ccm_1;c_ccm_2;c_ccm_3;c_ccm_4];

constr_List = [ sos(p_W_low);sos(p_W_up);
    sos(p_CCM);
    sos(su_1); sos(su_2);
    sos(su_3); sos(su_4);
    sos(sl_1); sos(sl_2);
    sos(sl_3); sos(sl_4);
    W_bounds;W_cond;
    sos(killing_11); sos(killing_11_2);
    sos(killing_12); sos(killing_12_2);
    sos(killing_22); sos(killing_22_2);
    sos(s_ccm_1); sos(s_ccm_2); sos(s_ccm_3); sos(s_ccm_4)];

options = sdpsettings('solver','mosek','verbose',0);
SOS_soln = solvesos(constr_List,[],options,coeff_List);




%% Parametrize W

% w_states = [x1,x2];
w_states = x(1);

w_order = 2;
w_poly = monomials(w_states,0:w_order);
W_list = cell(length(w_poly),1);

[prog, W_list{1}] = prog.newSym(n);
W = W_list{1}*w_poly(1);

for i = 2:length(w_poly)
    [prog, W_list{i}] = prog.newSym(n);
    W = W + W_list{i}*w_poly(i);
end

[prog, W_upper] = prog.newPSD(n);

dW_f = diff(W(:),x(1))*f;
dW_f = reshape(dW_f,n,n);

%%

%Lagrange multipliers
box_lim = [x(1)+x1_lim; x1_lim-x(1);
    x(2)+x2_lim; x2_lim-x(2)];
%            x3+x3_lim; x3_lim-x3];

l_order = 4;
l_def_states = [w_states'; dfor]';

[prog, Ll] = prog.newSOSPoly(monomials(l_def_states,0:l_order),2);
[prog, Lu] = prog.newSOSPoly(monomials(l_def_states,0:l_order),2);

l_ccm_states = [x(1);x(2);dtre]';
lc_order = 6;

[prog, Lc] = prog.newSOSPoly(monomials(l_ccm_states,0:lc_order),4);

%W uniform bounds
prog = prog.withPos(w_lower-1);
prog = prog.withPSD(w_upper*eye(n)-W_upper);

%Condition bound
prog = prog.withPos(condn*w_lower - w_upper);

%W pos def
prog = prog.withSOS((dfor'*W*dfor - w_lower*(dfor'*dfor)) - Ll'*box_lim(1:2));
prog = prog.withSOS(dfor'*(W_upper - W)*dfor - Lu'*box_lim(1:2));

%CCM condition
R_CCM = -(-dW_f(1:3,1:3) + df_perp*W*B_perp + B_perp'*W*df_perp' + 2*lambda*W(1:3,1:3));
prog = prog.withSOS((dtre'*R_CCM*dtre - ccm_eps*(dtre'*dtre)) - Lc'*box_lim);

options = spot_sdp_default_options();
% options.solveroptions.MSK_IPAR_BI_CLEAN_OPTIMIZER = 'MSK_OPTIMIZER_INTPNT';
% options.solveroptions.MSK_IPAR_INTPNT_BASIS = 'MSK_BI_NEVER';
options.verbose = return_metric;

%Norm constraint
free_vars = [prog.coneVar; prog.freeVar];
len = length(free_vars);
[prog, a] = prog.newPos(len);
prog = prog.withPos(-free_vars + a);
prog = prog.withPos(free_vars + a);

SOS_soln = prog.minimize(trace(W_scale*W_upper) + (1e-3)*sum(a), @spot_mosek, options);

solved = ~SOS_soln.status.strcmp('STATUS_PRIMAL_AND_DUAL_FEASIBLE');
w_lower = double(SOS_soln.eval(w_lower));
w_upper = double(SOS_soln.eval(w_upper));

if (return_metric)
    if (solved==0)
        disp('feasible, getting results...');
        
        W_sol = zeros(n,n,length(w_poly));
        for i = 1:length(w_poly)
            W_sol(:,:,i) = clean(double(SOS_soln.eval(W_list{i})),1e-3);
        end
        
        dw_poly_x1 = diff(w_poly,x(1));
        dw_poly_x2 = diff(w_poly,x(2));
        
        W_upper_mat = clean(double(SOS_soln.eval(W_upper)),1e-3);
        
        pause;
        
        %% Create monomial functions
        w_poly_fnc = mss2fnc(w_poly,x,randn(length(x),2));
        dw_poly_x1_fnc = mss2fnc(dw_poly_x1,x,randn(length(x),2));
        dw_poly_x2_fnc = mss2fnc(dw_poly_x2,x,randn(length(x),2));
        
        %% Put together
        W_exec = 'W_eval = @(ml)';
        
        for i = 1:length(w_poly)
            if i<length(w_poly)
                W_exec = strcat(W_exec,sprintf('W_sol(:,:,%d)*ml(%d) +',i,i));
            else
                W_exec = strcat(W_exec,sprintf('W_sol(:,:,%d)*ml(%d);',i,i));
            end
        end
        
        %% Execute
        eval(W_exec);
        save('metric_FLR_vectorized.mat','W_eval','w_poly_fnc','dw_poly_x1_fnc','W_upper');
        
    end
end